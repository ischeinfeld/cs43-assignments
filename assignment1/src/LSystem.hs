module LSystem where

import qualified Data.Map as M
import Data.Char (digitToInt)


-- Define the datatype representing the LSystem. Note that we derive the
-- instance for the Ord typeclass representing ordered values, since we want to
-- use Actions as keys in a M.Map (provided by the Data.Map import).

data Action = Draw | Move | RTurn | LTurn | Mark | Revert | Constant Int
  deriving (Eq, Ord, Show)


-- To simplefy writing rules, we write functions that can decode them from
-- characters and strings.

readAction :: Char -> Action
readAction char = case char of
  'D' -> Draw
  'M' -> Move
  '+' -> RTurn
  '-' -> LTurn
  '[' -> Mark
  ']' -> Revert
  x   -> Constant $ digitToInt x


-- TODO complete this function which reads a string as a list of actions.
-- Use readAction from above, recalling that String = [Char]

readActions :: String -> [Action]
readActions rule = undefined


------------------------------------------
-- Rewrite rules approach #1 (Implemented)
------------------------------------------

-- One way to define a rule set is using a function and pattern matching.
-- For example, we could define Rules to be functions :: Action -> [Action]

type Rules = Action -> [Action] -- defines type synonym


-- One example set of Rules could be the following.

rules1 :: Rules    -- same as writing rules :: Action -> [Action]
rules1 Draw = [Draw, Mark, RTurn, Draw, Revert,
               Draw, Mark, LTurn, Draw, Revert, Draw]
rules1 x    = [x]  -- any action besides Draw is rewritten with itself


-- Now we can write a function to rewrite a list of actions with the 
-- next generation of actions, applying a Rules function

rewrite :: Rules -> [Action] -> [Action]
rewrite rules actions = concat $ map rules actions


-- and we can define a function returning an infinite list of generations
-- from an initial list of actions (the axiom) and a Rules function

generate :: [Action] -> Rules -> [[Action]]
generate axiom rules = iterate (rewrite rules) axiom

-- NOTE the starter code draws the system generated by 
--    generations [Draw] rules1
-- You can change this in the last line of app/Main.hs if you want to write
-- your own rules.


-----------------------------------------
-- Rewrite rules approach #2 (Incomplete)
-----------------------------------------

-- Another way to encode rules is to store them as a map. We define a
-- type synonym for a Map from keys of type Action to values of type [Action],
-- where each key-value pair represents a rewrite rule.

type RuleMap = M.Map Action [Action] -- map with keys :: Action and vals :: [Action]


-- One example RuleMap could be the following.

ruleMap1 :: RuleMap
ruleMap1 = M.fromList [ (readAction '0', readActions "D[+0]D[-0]+0")
                      , (readAction 'D', readActions "DD") ]


-- Now we can write a function to return a Rules function from a RuleMap.
-- Note here that we can think of applyRuleMap as taking a RuleMap and returning
-- a Rules function similar to `rules1` defined above, or we can 
-- think of it as a function of two arguments taking a RuleMap and an Action,
-- and returning the rewrite as an [Action]. This allows us to write it as a
-- function of two arguments, (taking ruleMap and action), and later use it as a
-- function of one argument returning a new function.

applyRuleMap :: RuleMap -> Rules -- equivalent to RuleMap -> Action -> [Action]
applyRuleMap ruleMap action = 
  case M.lookup action ruleMap of
    Nothing -> [action]
    Just actions -> actions


-- TODO Now write a function to rewrite a list of actions with the 
-- next generation of actions, applying the rules from a RuleMap.
-- Note that `applyRuleMap ruleMap` will have the same type as `rules` in 
-- the implementation of rewrite above.

rewriteByMap :: RuleMap -> [Action] -> [Action]
rewriteByMap ruleMap actions = undefined


-- TODO Finally, write a function to generate an infinite list of generations
-- from an axiom and a ruleMap, using rewriteByMap defined above.

generateByMap :: [Action] -> RuleMap -> [[Action]]
generateByMap axiom ruleMap = undefined


-- TODO To use this new rule encoding, modify the code for generating
-- diagrams in app/Main.hs, replacing
--    generations [Draw] rules1
-- with the following 
--    generationsByMap [Constant 0] ruleMap1
-- to draw the system defined by the axiom [Constant 0]
-- and the rules in ruleMap1.

-- TODO Optional: Come up with your own rules, encode them as a RuleMap, and 
-- generate the corresponding diagrams for different generations.
